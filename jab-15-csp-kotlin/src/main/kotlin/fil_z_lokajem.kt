/*
 * This source file was generated by the Gradle 'init' task
 */
package org.seweryn
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.selects.select

const val N = 5


sealed class ForkReq {
    data class Chce(val t: Int) : ForkReq()
    data class Odklada(val t: Int) : ForkReq()
}



suspend fun lokaj(
    chceCh: Array<Channel<Unit>>,
    wychodzeCh: Array<Channel<Unit>>
) {
    var wolnych = N-1
    while (true) {
        // nienazwany wybór: (i:0..4) wolnych>0; Filozof(i)?Chce()
        //                | (i:0..4) Filozof(i)?Wychodze()
        select<Unit> {
            // wejścia
            for (i in 0 until N) {
                if (wolnych > 0) {
                    chceCh[i].onReceive {
                        wolnych -= 1
                        println("Lokaj: wpuszczam filozofa $i, wolnych=$wolnych")
                    }
                }
            }
            // wyjścia
            for (i in 0 until N) {
                wychodzeCh[i].onReceive {
                    wolnych += 1
                    println("Lokaj: filozof $i wychodzi, wolnych=$wolnych")
                }
            }
        }
    }
}


suspend fun filozof(id: Int, forkReq: Array<Channel<ForkReq>>, lokajChanwe: Channel<Unit>,lokajChanwy: Channel<Unit> ) {
    val leftFork = (2*id+1)%(2*N)
    val rightFork = (leftFork+1)%(2*N)
     println("fil $id moje kanaly to $leftFork i $rightFork")
     while (true) {
   //for(i in (1..2)){
        //println("Filozof $id: myśli")
        delay(100)
        lokajChanwe.send(Unit)

      
       // println("Filozof $id: zada lewy ")
        forkReq[leftFork].send(ForkReq.Chce(id))  

       // println("Filozof $id: ma lewy, zada prawego")
         delay(100)
        
        forkReq[rightFork].send(ForkReq.Chce(id))  

        println("Filozof $id: je!")
        delay(200)

        forkReq[rightFork].send(ForkReq.Odklada(id))
        forkReq[leftFork].send(ForkReq.Odklada(id))
        lokajChanwy.send(Unit)

    }
}

suspend fun widelec(i: Int, req: Array<Channel<ForkReq>>) {
    val leftPh = 2*i
    val rightPh = (2*i + 1) 
    println("widelec $i moje kanaly to $leftPh i $rightPh")
    while (true) {
        val eater = select<Int> {
            req[leftPh].onReceive { msg1-> 
              //  println("widelec $i odebral wiadomosc $msg1 ")
                val msgout=req[leftPh].receive()
               // println("widelec $i odebral druga wiadomosc $msgout ")
                leftPh
            }
            req[rightPh].onReceive { msg2-> 
               // println("widelec $i odebral wiadomosc $msg2")
                val msgout=req[rightPh].receive()
                //println("widelec $i odebral druga wiadomosc $msgout ")
                rightPh }
        }


        // Czekaj na Odklada (rendezvous)
       // val msgout=req[eater].receive() 
       // println("widelec $i odebral druga wiadomosc $msgout ")
    }
}

fun main() = runBlocking {
    val forkReq = Array(2*N) { Channel<ForkReq>() }

    val lokajChwe = Array(N) { Channel<Unit>() }
    val lokajChwy = Array(N) { Channel<Unit>() }
    launch { lokaj(lokajChwe, lokajChwy) }

    repeat(N) { i -> launch { widelec(i, forkReq) } }
    repeat(N) { i -> launch { filozof(i, forkReq, lokajChwe[i], lokajChwy[i]) } }

    // uruchom krótki demo, potem zakończ
    delay(5000)
    println("Koniec demo (program może być w deadlocku).")
    //coroutineContext.cancelChildren()
}
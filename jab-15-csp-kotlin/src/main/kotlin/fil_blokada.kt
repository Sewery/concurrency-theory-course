/*
 * This source file was generated by the Gradle 'init' task
 */
package com.seweryn
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.selects.select

const val N = 5


sealed class ForkReq {
    data class Chce(val t: Int) : ForkReq()
    data class Odklada(val t: Int) : ForkReq()
}
suspend fun filozof(id: Int, forkReq: Array<Channel<ForkReq>>) {
    val leftFork = (2*id+1)%(2*N)
    val rightFork = (leftFork+1)%(2*N)
     println("fil $id moje kanaly to $leftFork i $rightFork")
    while (true) {
        //println("Filozof $id: myśli")
        delay(100)

      
        println("Filozof $id: zada lewy ")
        forkReq[leftFork].send(ForkReq.Chce(id))  

        println("Filozof $id: ma lewy, zada prawego")
         delay(100)
        
        forkReq[rightFork].send(ForkReq.Chce(id))  

        println("Filozof $id: je!")
        delay(200)

        forkReq[rightFork].send(ForkReq.Odklada(id))
        forkReq[leftFork].send(ForkReq.Odklada(id))
    }
}

suspend fun widelec(i: Int, req: Array<Channel<ForkReq>>) {
    val leftPh = 2*i
    val rightPh = (2*i + 1) 
    println("widelec $i moje kanaly to $leftPh i $rightPh")
    while (true) {
        val eater = select<Int> {
            req[leftPh].onReceive { msg1-> 
                println("widelec $i odebral wiadomosc $msg1 ")
                val msgout=req[leftPh].receive()
                println("widelec $i odebral druga wiadomosc $msgout ")
                leftPh
            }
            req[rightPh].onReceive { msg2-> 
                println("widelec $i odebral wiadomosc $msg2")
                val msgout=req[rightPh].receive()
                println("widelec $i odebral druga wiadomosc $msgout ")
                rightPh }
        }


        // Czekaj na Odklada (rendezvous)
       // val msgout=req[eater].receive() 
       // println("widelec $i odebral druga wiadomosc $msgout ")
    }
}

fun main() = runBlocking {
    val forkReq = Array(2*N) { Channel<ForkReq>() }

    repeat(N) { i -> launch { widelec(i, forkReq) } }
    repeat(N) { i -> launch { filozof(i, forkReq) } }

    // uruchom krótki demo, potem zakończ
    delay(5000)
    println("Koniec demo (program może być w deadlocku).")
    coroutineContext.cancelChildren()
}